#+OPTIONS: toc:nil num:nil author:nil creator:nil \n:nil |:t
#+OPTIONS: @:t ::t ^:t -:t f:t *:t <:t

* デザパタ覚書

#+ATTR_HTML: border="1" rules="all" frame="all"
   | 名前                      | 意味                                       |
   |---------------------------+--------------------------------------------|
   | Iterator                  | 1つ1つ数え上げる                           |
   | Adapter                   | 一皮かぶせて再利用                         |
   | Template Method           | 具体的な処理をサブクラスに任せる           |
   | Factory Method            | インスタンス作成をサブクラスに任せる       |
   | Singleton                 | たった１つのインスタンス                   |
   | Prototype                 | コピーしてインスタンスを作る               |
   | Builder                   | 複雑なインスタンスを組み立てる             |
   | Abstract Factory          | 関連する部品を組み合わせて部品を作る       |
   | Bridge                    | 機能の階層と実装の階層を分ける             |
   | Strategy                  | アルゴリズムをごっそり切り替える           |
   | Composite                 | 容器と中身の同一視                         |
   | Decorator                 | 飾り枠と中身の同一視                       |
   | Visitor                   | 構造を渡り歩きながら仕事をする             |
   | Chain of Responsibility   | 責任のたらい回し                           |
   | Facade                    | シンプルな窓口                             |
   | Mediator                  | 相手は相談役一人だけ                       |
   | Observer                  | 状態の変化を通知する                       |
   | Memento                   | 状態を保存する                             |
   | State                     | 状態をクラスとして表現する                 |
   | Flyweight                 | 同じ物を共有して無駄を無くす               |
   | Proxy                     | 必要になってから作る                       |
   | Command                   | 命令をクラスにする                         |
   | Interpreter               | 文法規則をクラスで表現する                 |
   | Single Threaded Execution | この橋を渡れるのはたった一人               |
   | Immutable                 | 壊したくとも壊せない                       |
   | Guarded Suspension        | 用意が出来るまで待つ                       |
   | Balking                   | 不要であればすぐにリターンする             |
   | Producer-Consumer         | 私が作りあなたが使う                       |
   | Read-Write Lock           | read中はwrite禁止                          |
   | Thread-Per-Message        | この仕事、やっといて                       |
   | Worker Thread             | 仕事がくるまで待ち仕事がきたら働く         |
   | Future                    | スレッドに処理を投げてその戻値が必要なとき |
   | Two-Phase Terminatin      | 外から Thread.kill せず、止まるように指示  |
   | Thread-Specific Storage   | スレッド内グローバル変数                   |
   | Null Object               | なにもしないオブジェクトにしてかわす       |
   | Object pool               | 生成に時間がかかるものを使い回して高速化   |

#+ATTR_HTML: border="1" rules="all" frame="all"
  | 用途                                 | 種類                                |
  |--------------------------------------+-------------------------------------|
  | スレッドに処理を投げる→戻値必要     | Future                              |
  | スレッドに処理を投げる→戻値不要     | Thread Per Message                  |
  | スレッド内で処理できるまで→待つ     | Guarded Suspention or Worker Thread |
  | スレッド内で処理できるまで→待たない | Balking                             |
  | 生産スレ→SizedQueue→使用スレ       | Producer Consumer                   |

** Object pool

  : class X
  :   attr_accessor :active
  : end
  :
  : class C
  :   attr_accessor :pool
  :
  :   def initialize
  :     @size = 2
  :     @pool = []
  :   end
  :
  :   def new_x
  :     x = @pool.find{|e|!e.active}
  :     unless x
  :       if @pool.size < @size
  :         x = X.new
  :         @pool << x
  :       end
  :     end
  :     if x
  :       x.active = true
  :     end
  :     x
  :   end
  : end
  :
  : i = C.new
  : a = i.new_x                  # => #<X:0x007fd1cb08d5c8 @active=true>
  : b = i.new_x                  # => #<X:0x007fd1cb08d140 @active=true>
  : c = i.new_x                  # => nil
  : a.active = false
  : c = i.new_x                  # => #<X:0x007fd1cb08d5c8 @active=true>

** Null Object

   : class Logger
   :   def info(str)
   :     str
   :   end
   : end
   :
   : logger = Logger.new
   : logger.info("x")                # => "x"

   logger を無効にする

   : class NullObject
   :   def info(str)
   :   end
   : end

   : logger = NullObject.new
   : logger.info("x")                # => nil

** Producer Consumer

   生産スレが作ってキューに入れて使用スレがpopする。
   SizedQueueのサイズの小さいほど流れが悪くなる。
   以下の例はSizedQueueのサイズが1しかないのでconsumerがpopしてくれないと次をpushできない。

   : queue = SizedQueue.new(1)
   : producer = Thread.start{
   :   4.times {|i|
   :     p ["作成", i]
   :     queue.push(i)
   :   }
   :   p "作成側は先に終了"
   : }
   : consumer = Thread.start{
   :   4.times {
   :     p ["使用", queue.pop]
   :     sleep(0.01)
   :   }
   : }
   : producer.join
   : consumer.join
   : # >> ["作成", 0]
   : # >> ["作成", 1]
   : # >> ["使用", 0]
   : # >> ["作成", 2]
   : # >> ["使用", 1]
   : # >> ["作成", 3]
   : # >> ["使用", 2]
   : # >> "作成側は先に終了"
   : # >> ["使用", 3]

** Read Write Lock

   : class Buffer
   :   def initialize
   :     @sync = Sync.new
   :     @str = ""
   :   end
   :
   :   def write(_str)
   :     @sync.synchronize(:EX) do
   :       _str.chars.with_index do |c, i|
   :         sleep(0.0001)
   :         @str[i] = c
   :       end
   :     end
   :   end
   :
   :   def read
   :     @sync.synchronize(:SH) do
   :       @str.size.times.collect{|i|
   :         sleep(0.001)
   :         @str[i]
   :       }.join
   :     end
   :   end
   : end

   書き込みスレッドと、読み込みスレッドを並列で起動して、お互いが干渉するようにする

   : buffer = Buffer.new
   : w = Thread.start do
   :   ("A".."Z").cycle{|c|
   :     buffer.write(c.to_s * 64)
   :     sleep(0.001)
   :   }
   : end
   : r = Thread.start do
   :   10.times do
   :     sleep(0.001)
   :     p buffer.read
   :   end
   : end
   : r.join
   : w.kill

   でも結果は壊れてない

   : # >> "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
   : # >> "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
   : # >> "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
   : # >> "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
   : # >> "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
   : # >> "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
   : # >> "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG"
   : # >> "HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH"
   : # >> "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII"
   : # >> "JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ"

   @sync.synchronize ブロックを使わなかった場合は以下の通り

   : # >> AAAAAAA
   : # >> BBBBBBBBBBCCCCCCCCCCCDDDDDDDDDDDEEEEEEEEEEEFFFFFFFFFFGGGGGGGGGGG
   : # >> IIIIIIIIIIJJJJJJJJJJJKKKKKKKKKKKLLLLLLLLLLMMMMMMMMMMMNNNNNNNNNNO
   : # >> PPPPPPPPPPQQQQQQQQQQQRRRRRRRRRRRSSSSSSSSSSTTTTTTTTTTTUUUUUUUUUUU
   : # >> WWWWWWWWWWXXXXXXXXXXXYYYYYYYYYYYYZZZZZZZZZZAAAAAAAAAAABBBBBBBBBB
   : # >> DDDDDDDDDDDEEEEEEEEEEEEFFFFFFFFFFFGGGGGGGGGGHHHHHHHHHHHIIIIIIIII
   : # >> JJKKKKKKKKKKKLLLLLLLLLLLMMMMMMMMMMNNNNNNNNNNNOOOOOOOOOOOPPPPPPPP
   : # >> QQRRRRRRRRRRRSSSSSSSSSSTTTTTTTTTTTUUUUUUUUUUVVVVVVVVVVVWWWWWWWWW
   : # >> XXYYYYYYYYYYYZZZZZZZZZZZAAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCCDDDDDDD
   : # >> EEEEFFFFFFFFFFFGGGGGGGGGGGHHHHHHHHHHHIIIIIIIIIIIJJJJJJJJJJJKKKKK

**  Worker Thread - 仕事がくるまで待ち仕事がきたら働く

    : class Channel < SizedQueue
    :   attr_reader :threads
    :
    :   def initialize(size)
    :     super(size)
    :     @threads = size.times.collect do |i|
    :       Thread.start(i) do |i|
    :         loop do
    :           request = pop
    :           p "スレッド#{i}が#{request}を担当"
    :           sleep(1)
    :         end
    :       end
    :     end
    :   end
    : end

    1つのワーカーだけだと 3.3 秒。(4秒になってないのは、たぶん最後の sleep(1) が開始した時点で status == "sleep" になってるから？)

    : channel = Channel.new(1)
    : t = Time.now
    : 4.times{|i|channel << i}
    : nil until channel.size.zero? && channel.threads.all?{|t|t.status == "sleep"}
    : puts "%.1f s" % (Time.now - t)
    : # >> "スレッド0が0を担当"
    : # >> "スレッド0が1を担当"
    : # >> "スレッド0が2を担当"
    : # >> "スレッド0が3を担当"
    : # >> 3.3 s

    4つのワーカーだと処理が分散してすぐ終わる

    : channel = Channel.new(4)
    : t = Time.now
    : 4.times{|i|channel << i}
    : nil until channel.size.zero? && channel.threads.all?{|t|t.status == "sleep"}
    : puts "%.1f s" % (Time.now - t)
    : # >> "スレッド1が0を担当"
    : # >> "スレッド0が1を担当"
    : # >> "スレッド3が2を担当"
    : # >> "スレッド2が3を担当"
    : # >> 0.8 s

** Balking (ボーキング) - 実行できるまで待たない

   待つのではなく、すぐに *リターン* する。待つ場合は Guarded Suspention になる。
   一つのインスタンスの複数のスレッドで実行しているとき一部だけ排他制御を行うには synchronize ブロックで囲む。

   以下の例は a b c を順番に発動していく。
   ただ a の処理が 0.1 秒かかっているため、直後に発動した b は a が処理中のためリターンしている。
   aの処理が終わったころに発動した c は実行できていることがわかる。

   : class C
   :   include Mutex_m
   :
   :   def initialize
   :     super
   :     @change = false
   :   end
   :
   :   def execute(str, t)
   :     synchronize do
   :       if @change
   :         p "処理中のため#{str}はスキップ"
   :         return
   :       end
   :       @change = true
   :
   :       p str
   :       sleep(t) # sleepはsynchronizeの中で行わないとエラーになる
   :
   :       @change = false
   :     end
   :   end
   : end
   :
   : x = C.new
   : threads = []
   : threads << Thread.start{x.execute("a", 0.1)}
   : threads << Thread.start{x.execute("b", 0)}
   : sleep(0.1)
   : threads << Thread.start{x.execute("c", 0)}
   : threads.collect(&:join)
   : # >> "a"
   : # >> "処理中のためbはスキップ"
   : # >> "c"

** Active Object - 非同期メッセージを受け取る

   どんなときに有用か？

   : class C
   :   def process
   :     1 + 2
   :   end
   : end
   :
   : obj = C.new
   : obj.process

   ここで、すぐに実行する必要がない 1 + 2 の処理が重すぎる場合。

   : class C
   :   attr_accessor :queue
   :
   :   def initialize
   :     @queue = Queue.new
   :     Thread.start do
   :       loop { @queue.pop.call }  # バックグランド処理を永遠と回す
   :     end
   :   end
   :
   :   def process
   :     @queue << proc{p 1 + 2}
   :   end
   : end
   :
   : obj = C.new
   : obj.process
   :
   : nil until obj.queue.empty?

   C.process の中の処理が変わっただけでインタフェースはそのまま、というところが重要

** Two Phase Terminatin

   外から Thread.kill するんじゃなくて止まるように指示

   : t = Thread.start do
   :   2.times do |i|
   :     if Thread.current["interrupt"]
   :       break
   :     end
   :     p "処理中: #{i}"
   :     sleep(0.2)
   :   end
   :   p "終了処理"
   : end
   : sleep(0.1)
   : t["interrupt"] = true
   : t.join
   : # >> "処理中: 0"
   : # >> "終了処理"

** Guarded Suspention - 実行できるまで待つ

   : queue = Queue.new
   :
   : send_num = 10
   :
   : sender = Thread.start do
   :   Thread.current[:data] = []
   :   send_num.times do |i|
   :     sleep(rand(0..0.01))
   :     queue << i
   :     Thread.current[:data] << i
   :   end
   : end
   :
   : receiver = Thread.start do
   :   Thread.current[:data] = []
   :   send_num.times do
   :     sleep(rand(0..0.001))
   :     # pop出来ないとスレッドが自動停止してくれる。popだけどFIFO。間違いそう。
   :     Thread.current[:data] << queue.pop
   :   end
   : end
   :
   : sender.join
   : receiver.join
   :
   : # 正常にデータが受け取れているか確認
   : sender[:data]   # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   : receiver[:data] # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

** Thread Specific Storage

   Thread.current["a"] はスレッド内グローバル変数

   : Thread.start{Thread.current["a"] = 1}.join
   : Thread.start{Thread.current["a"]}.value    # => nil

** Thread Per Message - 戻値不要

   : def request(x)
   :   Thread.start(x){|x|p x}
   : end
   :
   : request("a")
   : request("b")
   :
   : (Thread.list - [Thread.main]).each(&:join)
   : # >> "a"
   : # >> "b"

** Future - 戻値必要

   : def request(x)
   :   Thread.start(x){|x|x}
   : end
   :
   : t = []
   : t << request("A")
   : t << request("B")
   : t.collect(&:value) # => ["A", "B"]

** Mediator

   : class A
   :   attr_accessor :state
   :   def initialize(b)
   :     @b = b
   :     @state = true
   :   end
   :   def changed
   :     @b.visible = @state
   :   end
   : end
   :
   : class B
   :   attr_accessor :visible
   : end

   改善。A と B に Mediator のインスタンスを持たせて changed は Mediator のインスタンスに投げる。

   : class Mediator
   :   attr_reader :a, :b
   :   def initialize
   :     @a = A.new(self)
   :     @b = B.new(self)
   :   end
   :   def changed
   :     @b.visible = @a.state
   :   end
   : end
   :
   : class A
   :   attr_accessor :state
   :   def initialize(mediator)
   :     @mediator = mediator
   :     @state = true
   :   end
   :   def changed
   :     @mediator.changed
   :   end
   : end
   :
   : class B
   :   attr_accessor :visible
   :   def initialize(mediator)
   :     @mediator = mediator
   :   end
   : end

   : m = Mediator.new
   : m.a.state = true
   : m.a.changed
   : m.b.visible # => true

** Abstract Factory

   : class C
   :   def run
   :     A.new + B.new
   :   end
   : end

   ↓

   : class C
   :   def run
   :     @factory.new_x + @factory.new_y
   :   end
   : end

** Factory Method

   こういうのはあっとゆうまに search メソッドが肥大化する。
   で、Userのクラスメソッドとしてメソッドを分離するという *間違ったリファクタリング* を行ってしまいがち。

   : class User
   :   def self.search(query)
   :     ["name like ?", "%#{query}%"]
   :   end
   : end
   :
   : User.search("alice")                     # => ["name like ?", "%alice%"]

   そうなりそうなら次のように改善

   : class User
   :   def self.search(*args)
   :     UserSearch.new(self, *args).run
   :   end
   : end
   :
   : class UserSearch
   :   def initialize(model, query)
   :     @model = model
   :     @query = query
   :   end
   :   def run
   :     ["name like ?", "%#{@query}%"]
   :   end
   : end
   :
   : User.search("alice")   # => ["name like ?", "%alice%"]

   UserSearch の中でいくらメソッドを増やしても元のUserには影響がない。

   次は例が悪いけど @color から変換するメソッドを Player 自体に入れてしまって Player がクラスがカオスになってしまうケース。

   : class Player
   :   attr_accessor :color
   :   def initialize
   :     @color = :blue
   :   end
   : end

   ここでプレイヤーの色を #00F で返したかったので rgb メソッド定義した。これがダメ。

   : class Player
   :   def rgb
   :     if @color == :blue
   :       "#00F"
   :     end
   :   end
   : end

   改善

   : class ColorInfo
   :   attr_accessor :color
   :   def initialize(color)
   :     @color = color
   :   end
   :   def rgb
   :     "#00F"
   :   end
   : end
   :
   : class Player
   :   def color_info
   :     ColorInfo.new(@color)
   :   end
   : end
   :
   : Player.new.color_info.rgb            # => "#00F"

   こうすればいくらでも窮屈な状態から脱出できる。
   もし、青が欲しければ ColorInfo に足せばいい。

   : class ColorInfo
   :   def human_name
   :     "青"
   :   end
   : end
   :
   : Player.new.color_info.human_name     # => "青"

   もっと言うなら最初から @color は ColorInfo のインスタンスにしときゃいい。

   解釈間違っているかも。Factory Method じゃなくて単なる移譲？

** Chain of responsibility

   : class Chainable
   :   def initialize(_next = nil)
   :     @_next = _next
   :   end
   :   def support(q)
   :     if resolve?(q)
   :       answer(q)
   :     elsif @_next
   :       @_next.support(q)
   :     else
   :       "知らん"
   :     end
   :   end
   : end
   :
   : class Alice < Chainable
   :   def resolve?(q)
   :     q == "1+2は？"
   :   end
   :   def answer(q)
   :     "3"
   :   end
   : end
   :
   : class Bob < Chainable
   :   def resolve?(q)
   :     q == "2*3は？"
   :   end
   :   def answer(q)
   :     "6"
   :   end
   : end
   :
   : alice = Alice.new(Bob.new)
   : alice.support("1+2は？") # => "3"
   : alice.support("2*3は？") # => "6"
   : alice.support("2/1は？") # => "知らん"
   :
** Proxy

   decoratorに似ているけど decoratorほどデコレートしないし便利メソッドを追加しない。
   元のインスタンスを *呼ぶ* *呼ばない* *まねる* *あとで呼ぶ* ぐらいしかない。

   : class User
   :   attr_accessor :name, :point
   :   def initialize(name)
   :     @name = name
   :     @point = 0
   :   end
   :   def deposit(amount)
   :     @point += amount
   :   end
   : end

   ガードプロキシ(呼んだり、呼ばなかったり)

   : class UserProxy
   :   BlackList = ["alice"]
   :
   :   def initialize(user)
   :     @user = user
   :   end
   :
   :   def point
   :     @user.point
   :   end
   :
   :   def method_missing(*args)
   :     if BlackList.include?(@user.name)
   :       return
   :     end
   :     @user.send(*args)
   :   end
   : end
   :
   : user = User.new("alice")
   : user.deposit(1)
   : user.point                      # => 1
   :
   : user = UserProxy.new(User.new("alice"))
   : user.deposit(1)
   : user.point                      # => 0

   仮想プロキシ(まねる)

   : class VirtualPrinter
   :   def name
   :     "BJ10V"
   :   end
   :   def print(str)
   :   end
   : end

   遅延実行(あとで呼ぶ)

   : class VirtualPrinter
   :   def name
   :     "BJ10V"
   :   end
   :   def print(str)
   :     @printer ||= RealPrinter.new
   :     @printer.print(str)
   :   end
   : end
   :
   : class RealPrinter
   :   def initialize
   :     puts "とてつもなく時間がかかる初期化処理..."
   :   end
   :   def name
   :     "BJ10V"
   :   end
   :   def print(str)
   :     str
   :   end
   : end
   :
   : printer = VirtualPrinter.new
   : printer.name        # => "BJ10V"
   : printer.print("ok") # => "ok"
   : # >> とてつもなく時間がかかる初期化処理...

** Command + Composite

   : class Command
   :   def execute
   :     raise NotImplementedError, "#{__method__} is not implemented"
   :   end
   : end
   :
   : class FooCommand < Command
   :   def execute
   :     "a"
   :   end
   : end
   :
   : class BarCommand < Command
   :   def execute
   :     "b"
   :   end
   : end
   :
   : class CompositeCommand < Command
   :   def initialize
   :     @commands = []
   :   end
   :   def <<(command)
   :     @commands << command
   :   end
   :   def execute
   :     @commands.collect(&:execute)
   :   end
   : end
   :
   : command = CompositeCommand.new
   : command << FooCommand.new
   : command << BarCommand.new
   :
   : command.execute                 # => ["a", "b"]

   コードブロックを使ってクラス爆発を防ぐ

   : class BazCommand < Command
   :   def initialize(&block)
   :     @command = block
   :   end
   :   def execute
   :     @command.call
   :   end
   : end
   :
   : command << BazCommand.new{"c"}
   : command << BazCommand.new{"d"}
   :
   : command.execute                 # => ["a", "b", "c", "d"]

** Prototype

   クラスベース

   : class Cell; end                                # 細胞
   : class Plankton < Cell; end                     # プランクトン < 細胞
   : class Fish < Plankton; end                     # 魚 < プランクトン
   : class Monkey < Fish; def speek?; true end; end # 猿 < 魚
   : class Human < Monkey; end                      # 人間 < 猿
   :
   : Human.new.speek?                # => true

   プロトタイプベース。JavaScript はこのタイプ。

   : cell = Object.new
   : plankton = cell.clone
   : fish = plankton.clone
   : monkey = fish.clone.tap{|o|def o.speek?; true end}
   : human = monkey.clone
   : human.speek?                    # => true

   その他の例

   : class Piece < Struct.new(:name)
   : end
   :
   : class Box
   :   attr_accessor :showcase
   :   def initialize
   :     @showcase = {
   :       :rook => Piece.new("飛"),
   :     }
   :   end
   :   def create(name)
   :     @showcase[name].clone
   :   end
   : end
   :
   : box = Box.new
   : box.create(:rook).name     # => "飛"

** Template Method

   : class Base
   :   def build
   :     "(#{body})"
   :   end
   : end
   :
   : class App < Base
   :   def body
   :     "ok"
   :   end
   : end
   :
   : App.new.build                   # => "(ok)"

** Iterator

   i が邪魔

   : ary = ["a", "b", "c"]
   : i = 0
   : while i < ary.size
   :   p ary[i]
   :   i += 1
   : end

   ここで Iterator

   : class Iterator
   :   def initialize(object)
   :     @object = object
   :     @index = 0
   :   end
   :   def has_next?
   :     @index < @object.size
   :   end
   :   def next
   :     @object[@index].tap{@index += 1}
   :   end
   : end
   :
   : class Array
   :   def iterator
   :     Iterator.new(self)
   :   end
   : end

   i が消えた

   : it = ary.iterator
   : while it.has_next?
   :   p it.next
   : end

   it も消す

   : class Array
   :   def iterator
   :     it = Iterator.new(self)
   :     while it.has_next?
   :       yield it.next
   :     end
   :   end
   : end
   :
   : ary.iterator{|v|p v}

** Mement

   簡易ブラックジャックを行うプレイヤー

   : class Player
   :   attr_accessor :cards
   :
   :   def initialize
   :     @cards = []
   :   end
   :
   :   def take
   :     @cards << rand(1..13)
   :   end
   :
   :   def score
   :     @cards.reduce(&:+)
   :   end
   : end

   5回カードを引くゲームを3回行うと全部21を越えてしまった

   : 3.times do
   :   player = Player.new
   :   5.times do
   :     player.take
   :   end
   :   player.score                  # => 33, 37, 52
   : end

   そこでMementパターン

   : class Player
   :   def create_mement
   :     @cards.clone
   :   end
   :
   :   def restore_memento(object)
   :     @cards = object.clone
   :   end
   : end

   21点未満の状態を保持しておき21を越えたら元に戻す

   : 3.times do
   :   player = Player.new
   :   mement = nil
   :   5.times do
   :     player.take
   :     if player.score < 21
   :       mement = player.create_mement
   :     elsif player.score > 21
   :       player.restore_memento(mement)
   :     end
   :   end
   :   player.score                  # => 18, 19, 15
   : end

** Visitor

   : Pathname.glob("**/*.rb") do |filename|
   :   p filename
   : end

   : NiconicoCrawler.run do |video|
   :   if video.mylist >= 10000 && video.title.match(/初音ミク/)
   :     open("#{video.title}.mp4", "w"){|f|f << video.read}
   :   end
   : end

** Flyweight

   : module Wave
   :   def self.load(file)
   :     p "load #{file}"
   :     file
   :   end
   : end
   :
   : class Sound
   :   def self.get(name)
   :     @cache ||= {}
   :     @cache[name] ||= Wave.load("#{name}.wav")
   :   end
   : end
   :
   : Sound.get("blue")               # => "blue.wav"
   : Sound.get("cyan")               # => "cyan.wav"
   : Sound.get("blue")               # => "blue.wav"
   : # >> "load blue.wav"
   : # >> "load cyan.wav"

** Builder

   : class Node
   :   attr_reader :name, :nodes
   :
   :   def initialize(name)
   :     @name = name
   :     @nodes = []
   :   end
   : end

   nodes << Node.new ばっかり

   : root = Node.new("root")
   : root.nodes << Node.new("a")
   : root.nodes << Node.new("b")
   : root.nodes << (c = Node.new("c"))
   : c.nodes << Node.new("d")
   : c.nodes << Node.new("e")
   : c.nodes << (f = Node.new("f"))
   : f.nodes << Node.new("g")
   : f.nodes << Node.new("h")

   : root.nodes.collect{|e|e.name}                       # => ["a", "b", "c"]
   : root.nodes.last.nodes.collect{|e|e.name}            # => ["d", "e", "f"]
   : root.nodes.last.nodes.last.nodes.collect{|e|e.name} # => ["g", "h"]

   改善

   : class Builder
   :   attr_reader :root
   :
   :   def self.build(*args, &block)
   :     new(*args).tap(&block).root
   :   end
   :
   :   def initialize(root = nil)
   :     @root = root || Node.new("root")
   :   end
   :
   :   def <<(name)
   :     @root.nodes << Node.new(name)
   :   end
   :
   :   def directory(name)
   :     node = Node.new(name)
   :     yield self.class.new(node)
   :     @root.nodes << node
   :   end
   : end

   簡潔になった

   : root = Builder.build do |o|
   :   o << "a"
   :   o << "b"
   :   o.directory("c") do |c|
   :     c << "d"
   :     c << "e"
   :     c.directory("f") do |f|
   :       f << "g"
   :       f << "h"
   :     end
   :   end
   : end

   結果も同じ

   : root.nodes.collect{|e|e.name}                       # => ["a", "b", "c"]
   : root.nodes.last.nodes.collect{|e|e.name}            # => ["d", "e", "f"]
   : root.nodes.last.nodes.last.nodes.collect{|e|e.name} # => ["g", "h"]

*** mail gem の例

    これだと面倒なので

    : mail = Mail.new
    : mail.from    = Mail::AddressContainer.new("alice <alice@example.net>")
    : mail.to      = Mail::AddressContainer.new("bob <bob@example.net>")
    : mail.subject = "題名"
    : mail.body    = Mail::Body.new("本文")

    改善

    : mail = Mail.new
    : mail.from    = "alice <alice@example.net>"
    : mail.to      = "bob <alice@example.net>"
    : mail.subject = "題名"
    : mail.body    = "本文"

    内部でこっそりインスタンスを生成している

    : mail.from.class    # => Mail::AddressContainer
    : mail.to.class      # => Mail::AddressContainer
    : mail.subject.class # => String
    : mail.body.class    # => Mail::Body

** State

   : class OpenState
   :   def board
   :     "営業中"
   :   end
   : end
   :
   : class CloseState
   :   def board
   :     "準備中"
   :   end
   : end
   :
   : class Shop
   :   def change_state(hour)
   :     if (11..17).include?(hour)
   :       @state = OpenState.new
   :     else
   :       @state = CloseState.new
   :     end
   :   end
   :   def board
   :     @state.board
   :   end
   : end
   :
   : shop = Shop.new
   : shop.change_state(10)
   : shop.board                      # => "準備中"
   : shop.change_state(11)
   : shop.board                      # => "営業中"

** Facade

   何をやってんのかわからない

   : from = User.find_by_name("alice") || User.find_by_name("admin")
   : to = User.find_by_name!("bob")
   : transaction do
   :   message = Message.new(:date => Time.current)
   :   message.from = from
   :   message.to = to
   :   message.body = "こんちは".toutf8
   :   if message.valid?
   :     ...
   :   end
   :   message.save!
   : end

   改善

   : Message.deliver(:from => "alice", :to => "bob", :body => "こんちは")

** Bridge

   機能の階層と実装の階層を分けるって言ってもStrategyと何が違うのかよくわからない。
   要はDRYにしとけば拡張が楽ちんことらしい。
   以下のコードは x y の実装2つと、囲まない囲むの2つの機能を組み合わせると2x2で4つのクラスが必要になる。
   このまま拡張していって実装と機能がそれぞれ10個あると100個のクラスを作らないといけない。

   : class A
   :   def run
   :     "x"
   :   end
   : end
   :
   : class B
   :   def run
   :     "y"
   :   end
   : end
   :
   : class AA < A
   :   def run
   :     "(x)"
   :   end
   : end
   :
   : class BB < B
   :   def run
   :     "(y)"
   :   end
   : end

   改善

   : class A
   :   def initialize(obj)
   :     @obj = obj
   :   end
   :   def run
   :     @obj
   :   end
   : end
   :
   : class AA < A
   :   def run
   :     "(#{@obj})"
   :   end
   : end

** Decorator

   proxyにそっくりだけど、遅延実行や実行条件には感心がない。

   このクラスの

   : class User
   :   def name
   :     "alice"
   :   end
   : end

   インスタンスを渡してラップするのが普通

   : class UserDecorator
   :   def initialize(object)
   :     @object = object
   :   end
   :   def to_xxx
   :     "(#{@object.name})"
   :   end
   : end
   :
   : UserDecorator.new(User.new).to_xxx # => "(alice)"

   もっとシンプルにするなら

   : require "delegate"
   :
   : class UserDecorator < SimpleDelegator
   :   def to_xxx
   :     "(#{name})"
   :   end
   : end
   :
   : UserDecorator.new(User.new).to_xxx # => "(alice)"

   というか最初から継承してみる

   : class UserDecorator < User
   :   def to_xxx
   :     "(#{name})"
   :   end
   : end
   :
   : UserDecorator.new.to_xxx # => "(alice)"

   継承なら DelegateClass でもできるようだけど利点がよくわからない。Userが重複しているのが気持ち悪い。

   : require "delegate"
   :
   : class UserDecorator < DelegateClass(User)
   :   def initialize
   :     super(User.new)
   :   end
   :   def to_xxx
   :     "(#{name})"
   :   end
   : end
   :
   : UserDecorator.new.to_xxx # => "(alice)"

** Observer

   実行結果が不要なときに使う。
   結果が必要ならStrategyへ。
   Observer側に player を渡して player.add_observer(self) は、くどいのでやらない。

   密結合状態を

   : class Player
   :   def initialize
   :     @paint = Paint.new
   :     @network = Network.new
   :   end
   :
   :   def notify
   :     if @paint
   :       @paint.font(0, 0, status)
   :     end
   :     if @network
   :       @network.post(status)
   :     end
   :   end
   : end

   解消

   : class Player
   :   attr_accessor :observers
   :   def initialize
   :     @observers = []
   :   end
   :   def notify
   :     @observers.each do |observer|
   :       observer.update(self)
   :     end
   :   end
   : end
   :
   : player = Player.new
   : player.observers << Paint.new
   : player.observers << Network.new

*** 標準ライブラリ

    : require "observer"
    : class Player
    :   include Observable
    :   def notify
    :     changed
    :     notify_observers(self)
    :   end
    : end
    :
    : player = Player.new
    : player.add_observer(Paint.new)
    : player.add_observer(Network.new)
    : player.notify

    自分をオブザーバーにしてもいい

    : require "observer"
    : class Player
    :   include Observable
    :   def initialize
    :     add_observer(self)
    :   end
    :   def notify
    :     changed
    :     notify_observers(self)
    :   end
    :   def update(player)
    :     player                      # => #<Player:0x007ff9098472e0 ...>
    :   end
    : end
    :
    : player = Player.new
    : player.notify

** Singleton

   グローバル変数を使うぐらいなら

   : class C
   :   private_class_method :new
   :   def self.instance
   :     @instance ||= new
   :   end
   : end
   :
   : C.instance # => #<C:0x007f98e404a518>
   : C.instance # => #<C:0x007f98e404a518>

   標準ライブラリを使った場合

   : require "singleton"
   : class C
   :   include Singleton
   : end
   : C.instance # => #<C:0x007f98e509f558>
   : C.instance # => #<C:0x007f98e509f558>

** Strategy

   基本形

   : class Random
   :   def next
   :     rand(7)
   :   end
   : end
   :
   : class RedOnly
   :   def next
   :     6
   :   end
   : end
   :
   : # テトリミノのツモはダイス次第
   : class Player
   :   def initialize(dice)
   :     @dice = dice
   :   end
   :   def run
   :     7.times.collect{@dice.next}
   :   end
   : end
   :
   : Player.new(Random.new).run  # => [1, 5, 4, 1, 0, 0, 6]
   : Player.new(RedOnly.new).run # => [6, 6, 6, 6, 6, 6, 6]

   Rubyなら

   : class Player
   :   def initialize(&dice)
   :     @dice = dice
   :   end
   :   def run
   :     7.times.collect{@dice.call}
   :   end
   : end
   :
   : Player.new{rand(7)}.run  # => [2, 5, 5, 6, 6, 2, 0]
   : Player.new{6}.run        # => [6, 6, 6, 6, 6, 6, 6]

   これでクラスが爆発しなくなる

** Adapter

   ダメなクラスを

   : class Color
   :   def red
   :     "#00f"
   :   end
   : end

   ラップして再利用

   : class Palette < Color
   :   alias blue red
   : end
   : Palette.new.blue # => "#00f"

** シンプルなDSL

   : class Expression
   : end
   :
   : class Value < Expression
   :   def initialize(value)
   :     @value = value
   :   end
   :   def evaluate
   :     @value
   :   end
   : end
   :
   : class Add < Expression
   :   def initialize(left, right)
   :     @left, @right = left, right
   :   end
   :   def evaluate
   :     @left.evaluate + @right.evaluate
   :   end
   : end
   :
   : def A(l, r)
   :   Add.new(Value.new(l), Value.new(r))
   : end
   :
   : expr = A 1, 2
   : expr.evaluate # => 3

*** DSLの応用 - 他のコードに変換

    : class Expression
    : end
    :
    : class Value < Expression
    :   attr_accessor :value
    :   def initialize(value)
    :     @value = value
    :   end
    :   def evaluate
    :     ["mov  ax, #{@value}"]
    :   end
    : end
    :
    : class Add < Expression
    :   def initialize(left, right)
    :     @left, @right = left, right
    :   end
    :   def evaluate
    :     code = []
    :     code << @left.evaluate
    :     code << "mov  dx, ax"
    :     code << @right.evaluate
    :     code << "add  ax, dx"
    :   end
    : end
    :
    : def A(l, r)
    :   Add.new(Value.new(l), Value.new(r))
    : end
    :
    : expr = A 1, 2
    : puts expr.evaluate
    : # >> mov  ax, 1
    : # >> mov  dx, ax
    : # >> mov  ax, 2
    : # >> add  ax, dx

